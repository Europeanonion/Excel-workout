DISCLAIMER: The below are merely suggestions for the implementation of PWA Configuration. You should conduct your own necessary assessment and consider the correct implementation. Any UI suggestions should also reflect the current style of the application:

# Detailed Implementation Plan: PWA Features & Offline Functionality


Project structure:

@Europeanonion ➜ /workspaces/Excel-workout (PWA-configuration) $ tree -L 3 -I 'node_modules|.git|dist|build'
.
├── Critical Vulnerability fixes - potential.txt
├── PWA configuaration - next step.text
├── audit_report.md
├── coverage
│   ├── clover.xml
│   ├── coverage-final.json
│   ├── lcov-report
│   │   ├── base.css
│   │   ├── block-navigation.js
│   │   ├── favicon.png
│   │   ├── index.html
│   │   ├── prettify.css
│   │   ├── prettify.js
│   │   ├── sort-arrow-sprite.png
│   │   ├── sorter.js
│   │   └── src
│   └── lcov.info
├── dependencies_backup.txt
├── docs
├── jest.config.js
├── memory-bank
│   ├── HighLevelOverview.md
│   ├── Project notes
│   │   ├── AIAgentOptimizationAnalysis.md
│   │   ├── APIAbstractionLayerImplementation.md
│   │   ├── ArchitecturalRecommendationsPrioritized.md
│   │   ├── ExcelParser_AdvancedImprovementsAnalysis.md
│   │   ├── ExcelParser_ImplementedImprovements.md
│   │   ├── FirebaseIntegrationImplementation.md
│   │   └── TestSuiteImprovements.md
│   ├── ProjectStructureAnalysis.md
│   ├── README.md
│   ├── VERSION.md
│   ├── activeContext.md
│   ├── consolidated
│   │   └── memoryBank.md
│   ├── decisionLog.md
│   ├── productContext.md
│   ├── progress.md
│   ├── projectBrief.md
│   ├── shared
│   │   └── memoryBankHandler.md
│   ├── systemPatterns.md
│   └── techContext.md
├── package-lock.json
├── package.json
├── projectBrief.md
├── public
│   ├── index.html
│   ├── manifest.json
│   └── templates
│       └── workout-template.csv
├── src
│   ├── App.css
│   ├── App.test.tsx
│   ├── App.tsx
│   ├── ErrorBoundary.tsx
│   ├── components
│   │   ├── Auth
│   │   ├── ExcelUploader
│   │   ├── OnlineStatus
│   │   ├── ProgramList
│   │   ├── WorkoutDetails
│   │   └── WorkoutSession
│   ├── features
│   │   └── excelParsing
│   ├── firebase
│   │   ├── __mocks__
│   │   ├── auth.ts
│   │   ├── config.ts
│   │   ├── firestore.ts
│   │   └── sync.ts
│   ├── hooks
│   │   └── useExcelUpload.ts
│   ├── index.css
│   ├── index.tsx
│   ├── lib
│   │   └── indexedDB.ts
│   ├── reportWebVitals.ts
│   ├── serviceWorkerRegistration.ts
│   ├── services
│   │   ├── ServiceFactory.ts
│   │   ├── __mocks__
│   │   ├── implementations
│   │   ├── index.ts
│   │   └── interfaces
│   ├── setupTests.ts
│   └── types
│       ├── css.d.ts
│       ├── index.ts
│       └── lodash.d.ts
├── test-output.txt
├── tsconfig.json
└── workout.csv


## Phase 1: PWA Configuration Enhancement

### 1.1 Optimize Service Worker Registration

```typescript
// Update service worker configuration for better offline support
export function register(config?: Config) {
  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {
    // Existing registration code...
    
    // Add enhanced offline detection
    window.addEventListener('online', () => {
      console.log('Application is online');
      document.dispatchEvent(new CustomEvent('app-online'));
    });
    
    window.addEventListener('offline', () => {
      console.log('Application is offline');
      document.dispatchEvent(new CustomEvent('app-offline'));
    });
    
    // Add periodic sync registration (for background sync)
    navigator.serviceWorker.ready.then(registration => {
      if ('periodicSync' in registration) {
        try {
          // @ts-ignore - TypeScript might not recognize periodicSync yet
          registration.periodicSync.register('sync-workouts', {
            minInterval: 24 * 60 * 60 * 1000, // 24 hours
          });
        } catch (error) {
          console.error('Periodic sync could not be registered:', error);
        }
      }
    });
  }
}
```

### 1.2 Configure Workbox for Advanced Caching

First, install Workbox:

```bash
npm install workbox-webpack-plugin --save-dev
npm install workbox-window workbox-routing workbox-strategies workbox-expiration --save
```

Create a custom service worker file:

```javascript
import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies';

clientsClaim();

// Precache all static assets generated by webpack
precacheAndRoute(self.__WB_MANIFEST);

// App shell - serve index.html for all navigation requests
const fileExtensionRegexp = /\/[^/?]+\.[^/]+$/;
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html
  ({ request, url }) => {
    if (request.mode !== 'navigate') {
      return false;
    }
    if (url.pathname.startsWith('/_')) {
      return false;
    }
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// Cache CSS, JS, and Web Worker requests with a Stale While Revalidate strategy
registerRoute(
  ({ url }) => 
    url.origin === self.location.origin &&
    (url.pathname.endsWith('.js') || 
     url.pathname.endsWith('.css') ||
     url.pathname.endsWith('.worker.js')),
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
  })
);

// Cache images with a Cache First strategy
registerRoute(
  ({ request, url }) => 
    request.destination === 'image' ||
    url.pathname.endsWith('.png') ||
    url.pathname.endsWith('.jpg') ||
    url.pathname.endsWith('.jpeg') ||
    url.pathname.endsWith('.svg') ||
    url.pathname.endsWith('.gif'),
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
      }),
    ],
  })
);

// Cache API responses with Network First strategy
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-responses',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
      }),
    ],
  })
);

// Cache template files with a Stale While Revalidate strategy
registerRoute(
  ({ url }) => url.pathname.includes('/templates/'),
  new StaleWhileRevalidate({
    cacheName: 'template-files',
  })
);

// Handle background sync for data that failed to submit while offline
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-workout-data') {
    event.waitUntil(syncWorkoutData());
  }
});

// Background sync function to send queued data
async function syncWorkoutData() {
  const dbPromise = indexedDB.open('workout-sync-store', 1);
  
  dbPromise.onupgradeneeded = function(event) {
    const db = event.target.result;
    if (!db.objectStoreNames.contains('sync-queue')) {
      db.createObjectStore('sync-queue', { keyPath: 'id' });
    }
  };

  const db = await new Promise((resolve, reject) => {
    const request = dbPromise;
    request.onerror = reject;
    request.onsuccess = () => resolve(request.result);
  });

  const tx = db.transaction('sync-queue', 'readwrite');
  const store = tx.objectStore('sync-queue');

  // Get all items in the store
  const items = await new Promise((resolve) => {
    const request = store.getAll();
    request.onsuccess = () => resolve(request.result);
  });

  // Process each item in the queue
  for (const item of items) {
    try {
      await fetch(item.url, {
        method: item.method,
        headers: item.headers,
        body: item.body
      });
      // If successful, remove from queue
      store.delete(item.id);
    } catch (error) {
      console.error('Error syncing data:', error);
    }
  }

  await new Promise((resolve) => {
    tx.oncomplete = resolve;
  });
}

// Listen for push notifications
self.addEventListener('push', (event) => {
  const data = event.data.json();
  const options = {
    body: data.body,
    icon: '/logo192.png',
    badge: '/badge.png',
    data: data.data
  };

  event.waitUntil(
    self.registration.showNotification(data.title, options)
  );
});

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  event.waitUntil(
    clients.matchAll({ type: 'window' }).then(windowClients => {
      // Navigate existing window if available
      for (let client of windowClients) {
        if (client.url === '/' && 'focus' in client) {
          return client.focus();
        }
      }
      // Open new window if none exists
      if (clients.openWindow) {
        return clients.openWindow('/');
      }
    })
  );
});
```

### 1.3 Update Web App Manifest

```json
{
  "short_name": "Workout",
  "name": "Excel Workout PWA",
  "description": "Track and manage your workout programs from Excel files",
  "categories": ["fitness", "health", "productivity"],
  "id": "/",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192",
      "purpose": "any maskable"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512",
      "purpose": "any maskable"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#4CAF50",
  "background_color": "#ffffff",
  "orientation": "portrait",
  "screenshots": [
    {
      "src": "screenshot1.png",
      "sizes": "1280x720",
      "type": "image/png",
      "form_factor": "wide",
      "label": "Workout Dashboard"
    },
    {
      "src": "screenshot2.png",
      "sizes": "750x1334",
      "type": "image/png",
      "form_factor": "narrow",
      "label": "Mobile View"
    }
  ],
  "related_applications": [],
  "prefer_related_applications": false,
  "shortcuts": [
    {
      "name": "New Workout",
      "short_name": "New",
      "description": "Upload a new workout program",
      "url": "/upload",
      "icons": [{ "src": "icons/new.png", "sizes": "192x192" }]
    },
    {
      "name": "My Programs",
      "short_name": "Programs",
      "description": "View your workout programs",
      "url": "/programs",
      "icons": [{ "src": "icons/programs.png", "sizes": "192x192" }]
    }
  ]
}
```

## Phase 2: Offline Data Handling

### 2.1 Implement IndexedDB Wrapper

```typescript
import { WorkoutProgram, WorkoutSession } from '../types';

export class IndexedDBService {
  private dbName: string;
  private dbVersion: number;
  private db: IDBDatabase | null = null;

  constructor(dbName: string = 'excel-workout-db', dbVersion: number = 1) {
    this.dbName = dbName;
    this.dbVersion = dbVersion;
  }

  async initDB(): Promise<IDBDatabase> {
    if (this.db) return this.db;

    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);

      request.onerror = (event) => {
        console.error('IndexedDB error:', event);
        reject(new Error('Could not open IndexedDB'));
      };

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        
        // Create object stores if they don't exist
        if (!db.objectStoreNames.contains('programs')) {
          const programsStore = db.createObjectStore('programs', { keyPath: 'id' });
          programsStore.createIndex('name', 'name', { unique: false });
        }
        
        if (!db.objectStoreNames.contains('sessions')) {
          const sessionsStore = db.createObjectStore('sessions', { keyPath: 'id' });
          sessionsStore.createIndex('programId', 'programId', { unique: false });
          sessionsStore.createIndex('date', 'date', { unique: false });
        }
        
        if (!db.objectStoreNames.contains('sync-queue')) {
          db.createObjectStore('sync-queue', { keyPath: 'id' });
        }
      };

      request.onsuccess = (event) => {
        this.db = (event.target as IDBOpenDBRequest).result;
        resolve(this.db);
      };
    });
  }

  async getAllPrograms(): Promise<WorkoutProgram[]> {
    await this.initDB();
    return new Promise((resolve, reject) => {
      if (!this.db) return reject(new Error('Database not initialized'));

      const transaction = this.db.transaction(['programs'], 'readonly');
      const store = transaction.objectStore('programs');
      const request = store.getAll();

      request.onsuccess = () => resolve(request.result || []);
      request.onerror = () => reject(new Error('Failed to fetch programs'));
    });
  }

  async getProgram(id: string): Promise<WorkoutProgram | null> {
    await this.initDB();
    return new Promise((resolve, reject) => {
      if (!this.db) return reject(new Error('Database not initialized'));

      const transaction = this.db.transaction(['programs'], 'readonly');
      const store = transaction.objectStore('programs');
      const request = store.get(id);

      request.onsuccess = () => resolve(request.result || null);
      request.onerror = () => reject(new Error(`Failed to fetch program: ${id}`));
    });
  }

  async saveProgram(program: WorkoutProgram): Promise<void> {
    await this.initDB();
    return new Promise((resolve, reject) => {
      if (!this.db) return reject(new Error('Database not initialized'));

      const transaction = this.db.transaction(['programs'], 'readwrite');
      const store = transaction.objectStore('programs');
      const request = store.put(program);

      request.onsuccess = () => {
        this.addToSyncQueue({
          id: `program-${Date.now()}`,
          url: '/api/programs',
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(program),
        });
        resolve();
      };
      request.onerror = () => reject(new Error('Failed to save program'));
    });
  }

  async deleteProgram(id: string): Promise<void> {
    await this.initDB();
    return new Promise((resolve, reject) => {
      if (!this.db) return reject(new Error('Database not initialized'));

      const transaction = this.db.transaction(['programs'], 'readwrite');
      const store = transaction.objectStore('programs');
      const request = store.delete(id);

      request.onsuccess = () => {
        this.addToSyncQueue({
          id: `delete-program-${Date.now()}`,
          url: `/api/programs/${id}`,
          method: 'DELETE',
          headers: {},
          body: null,
        });
        resolve();
      };
      request.onerror = () => reject(new Error(`Failed to delete program: ${id}`));
    });
  }

  async saveSession(session: WorkoutSession): Promise<void> {
    await this.initDB();
    return new Promise((resolve, reject) => {
      if (!this.db) return reject(new Error('Database not initialized'));

      const transaction = this.db.transaction(['sessions'], 'readwrite');
      const store = transaction.objectStore('sessions');
      const request = store.put(session);

      request.onsuccess = () => {
        this.addToSyncQueue({
          id: `session-${Date.now()}`,
          url: '/api/sessions',
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(session),
        });
        resolve();
      };
      request.onerror = () => reject(new Error('Failed to save session'));
    });
  }

  async getSessions(programId: string): Promise<WorkoutSession[]> {
    await this.initDB();
    return new Promise((resolve, reject) => {
      if (!this.db) return reject(new Error('Database not initialized'));

      const transaction = this.db.transaction(['sessions'], 'readonly');
      const store = transaction.objectStore('sessions');
      const index = store.index('programId');
      const request = index.getAll(programId);

      request.onsuccess = () => resolve(request.result || []);
      request.onerror = () => reject(new Error(`Failed to fetch sessions for program: ${programId}`));
    });
  }

  private async addToSyncQueue(syncItem: any): Promise<void> {
    if (!navigator.onLine) {
      await this.initDB();
      return new Promise((resolve, reject) => {
        if (!this.db) return reject(new Error('Database not initialized'));

        const transaction = this.db.transaction(['sync-queue'], 'readwrite');
        const store = transaction.objectStore('sync-queue');
        const request = store.put(syncItem);

        request.onsuccess = () => {
          // Register for background sync if supported
          if ('serviceWorker' in navigator && 'SyncManager' in window) {
            navigator.serviceWorker.ready.then(registration => {
              registration.sync.register('sync-workout-data').catch(err => {
                console.error('Background sync registration failed:', err);
              });
            });
          }
          resolve();
        };
        request.onerror = () => reject(new Error('Failed to add to sync queue'));
      });
    }
  }
}

export default new IndexedDBService();
```

### 2.2 Create Offline Context Provider

```tsx
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';

interface OfflineContextType {
  isOnline: boolean;
  hasOfflineData: boolean;
  lastSyncTime: Date | null;
}

const OfflineContext = createContext<OfflineContextType>({
  isOnline: true,
  hasOfflineData: false,
  lastSyncTime: null
});

export const useOffline = () => useContext(OfflineContext);

interface OfflineProviderProps {
  children: ReactNode;
}

export const OfflineProvider: React.FC<OfflineProviderProps> = ({ children }) => {
  const [isOnline, setIsOnline] = useState<boolean>(navigator.onLine);
  const [hasOfflineData, setHasOfflineData] = useState<boolean>(false);
  const [lastSyncTime, setLastSyncTime] = useState<Date | null>(null);

  useEffect(() => {
    // Check if there's data in the sync queue
    const checkOfflineData = async () => {
      try {
        const dbRequest = indexedDB.open('excel-workout-db');
        dbRequest.onsuccess = (event) => {
          const db = (event.target as IDBOpenDBRequest).result;
          if (db.objectStoreNames.contains('sync-queue')) {
            const transaction = db.transaction(['sync-queue'], 'readonly');
            const store = transaction.objectStore('sync-queue');
            const countRequest = store.count();
            
            countRequest.onsuccess = () => {
              setHasOfflineData(countRequest.result > 0);
            };
          }
          db.close();
        };
      } catch (error) {
        console.error('Error checking offline data:', error);
      }
    };

    const handleOnlineStatusChange = () => {
      setIsOnline(navigator.onLine);
      if (navigator.onLine) {
        // When coming back online, check for data to sync
        checkOfflineData();
        // Try to trigger sync
        if ('serviceWorker' in navigator && 'SyncManager' in window) {
          navigator.serviceWorker.ready.then(registration => {
            registration.sync.register('sync-workout-data').catch(console.error);
          });
        }
      }
    };

    // Listen to online/offline events
    window.addEventListener('online', handleOnlineStatusChange);
    window.addEventListener('offline', handleOnlineStatusChange);
    
    // Check initial status
    checkOfflineData();
    
    // Listen for sync completion events from service worker
    const syncCompleteHandler = (event: Event) => {
      if ((event as CustomEvent).detail?.type === 'sync-complete') {
        setLastSyncTime(new Date());
        checkOfflineData();
      }
    };
    
    document.addEventListener('sync-complete', syncCompleteHandler);

    return () => {
      window.removeEventListener('online', handleOnlineStatusChange);
      window.removeEventListener('offline', handleOnlineStatusChange);
      document.removeEventListener('sync-complete', syncCompleteHandler);
    };
  }, []);

  return (
    <OfflineContext.Provider value={{ isOnline, hasOfflineData, lastSyncTime }}>
      {children}
    </OfflineContext.Provider>
  );
};
```

## Phase 3: Implement PWA Installation Experience

### 3.1 Create Install Prompt Component

```tsx
import React, { useState, useEffect } from 'react';
import './install-prompt.module.css';

interface BeforeInstallPromptEvent extends Event {
  prompt: () => Promise<void>;
  userChoice: Promise<{ outcome: 'accepted' | 'dismissed' }>;
}

const InstallPrompt: React.FC = () => {
  const [installPrompt, setInstallPrompt] = useState<BeforeInstallPromptEvent | null>(null);
  const [showPrompt, setShowPrompt] = useState(false);
  const [isIOS, setIsIOS] = useState(false);

  useEffect(() => {
    // Check if it's iOS
    const isIOSDevice = /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any).MSStream;
    setIsIOS(isIOSDevice);

    // Listen for the beforeinstallprompt event
    const handleBeforeInstallPrompt = (e: Event) => {
      // Prevent Chrome 67+ from automatically showing the prompt
      e.preventDefault();
      // Stash the event so it can be triggered later
      setInstallPrompt(e as BeforeInstallPromptEvent);
      // Show our custom install button
      setShowPrompt(true);
    };

    // Check if already installed
    const isAppInstalled = window.matchMedia('(display-mode: standalone)').matches ||
                          (window.navigator as any).standalone === true;
    
    if (!isAppInstalled) {
      window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
    }

    // Check if it should show after a week of usage
    const firstVisit = localStorage.getItem('firstVisitDate');
    if (!firstVisit) {
      localStorage.setItem('firstVisitDate', Date.now().toString());
    } else {
      const oneWeek = 7 * 24 * 60 * 60 * 1000;
      const shouldPrompt = Date.now() - parseInt(firstVisit) > oneWeek;
      
      // Only show after a week of usage and if the prompt exists
      if (shouldPrompt && installPrompt) {
        setShowPrompt(true);
      }
    }

    return () => {
      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
    };
  }, [installPrompt]);

  const handleInstallClick = () => {
    if (!installPrompt) return;

    // Show the install prompt
    installPrompt.prompt();

    // Wait for the user to respond to the prompt
    installPrompt.userChoice.then((choiceResult) => {
      if (choiceResult.outcome === 'accepted') {
        console.log('User accepted the install prompt');
      } else {
        console.log('User dismissed the install prompt');
      }
      // Clear the saved prompt as it can't be used again
      setInstallPrompt(null);
      setShowPrompt(false);
    });
  };

  const closePrompt = () => {
    setShowPrompt(false);
    // Don't show for another month
    localStorage.setItem('installPromptDismissed', Date.now().toString());
  };

  // Check if we should show the prompt
  if (!showPrompt) return null;

  // Different prompt for iOS vs other platforms
  return (
    <div className="install-prompt">
      {isIOS ? (
        <div className="ios-prompt">
          <button className="close-button" onClick={closePrompt} aria-label="Close">×</button>
          <h3>Install this Web App</h3>
          <p>Install this app on your home screen for offline use:</p>
          <ol>
            <li>Tap the share icon <span className="ios-share-icon"></span></li>
            <li>Scroll down and tap "Add to Home Screen"</li>
            <li>Tap "Add" in the top-right corner</li>
          </ol>
        </div>
      ) : (
        <div className="install-banner">
          <div className="banner-content">
            <img src="/logo192.png" alt="App logo" className="app-icon" />
            <div className="banner-text">
              <h3>Add Excel Workout to Home Screen</h3>
              <p>Install this app for quick access and offline use</p>
            </div>
          </div>
          <div className="banner-actions">
            <button onClick={closePrompt} className="dismiss-button">Not now</button>
            <button onClick={handleInstallClick} className="install-button">Install</button>
          </div>
        </div>
      )}
    </div>
  );
};

export default InstallPrompt;
```

### 3.2 Add CSS for Install Prompt

```css
.install-prompt {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 1000;
  animation: slideUp 0.3s ease-out forwards;
}

@keyframes slideUp {
  from {
    transform: translateY(100%);
  }
  to {
    transform: translateY(0);
  }
}

.ios-prompt {
  background-color: rgba(255, 255, 255, 0.95);
  border-top: 1px solid #e0e0e0;
  border-radius: 15px 15px 0 0;
  padding: 20px;
  box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
  position: relative;
}

.ios-share-icon {
  display: inline-block;
  width: 20px;
  height: 20px;
  background-image: url('/icons/ios-share.svg');
  background-size: contain;
  background-repeat: no-repeat;
  vertical-align: middle;
  margin-left: 5px;
}

.close-button {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  font-size: 24px;
  cursor: pointer;
  color: #666;
}

.install-banner {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: #ffffff;
  border-top: 1px solid #e0e0e0;
  padding: 12px 16px;
  box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
}

.banner-content {
  display: flex;
  align-items: center;
}

.app-icon {
  width: 48px;
  height: 48px;
  margin-right: 16px;
  border-radius: 8px;
}

.banner-text {
  flex: 1;
}

.banner-text h3 {
  margin: 0 0 4px 0;
  font-size: 16px;
  color: #333;
}

.banner-text p {
  margin: 0;
  font-size: 14px;
  color: #666;
}

.banner-actions {
  display: flex;
  gap: 8px;
}

.dismiss-button {
  padding: 8px 12px;
  background: none;
  border: 1px solid #ccc;
  border-radius: 4px;
  cursor: pointer;
  color: #666;
}

.install-button {
  padding: 8px 16px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 4px;
  font-weight: 500;
  cursor: pointer;
}

/* Media queries for responsive layout */
@media (max-width: 600px) {
  .install-banner {
    flex-direction: column;
    align-items: stretch;
  }
  
  .banner-content {
    margin-bottom: 12px;
  }
  
  .banner-actions {
    justify-content: flex-end;
  }
}
```

### 3.3 Add Offline Indicator Component

```tsx
import React from 'react';
import { useOffline } from '../../context/OfflineContext';
import './offline-indicator.module.css';

export const OfflineIndicator: React.FC = () => {
  const { isOnline, hasOfflineData, lastSyncTime } = useOffline();
  
  // Format the last sync time in a user-friendly way
  const formatLastSync = (date: Date | null): string => {
    if (!date) return 'Never';
    
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMin = Math.round(diffMs / 60000);
    
    if (diffMin < 1) return 'Just now';
    if (diffMin === 1) return '1 minute ago';
    if (diffMin < 60) return `${diffMin} minutes ago`;
    
    const diffHours = Math.floor(diffMin / 60);
    if (diffHours === 1) return '1 hour ago';
    if (diffHours < 24) return `${diffHours} hours ago`;
    
    const diffDays = Math.floor(diffHours / 24);
    if (diffDays === 1) return '1 day ago';
    return `${diffDays} days ago`;
  };

  if (isOnline && !hasOfflineData) {
    return null; // Don't show anything if online and no pending sync
  }

  return (
    <div className={`offline-indicator ${isOnline ? 'syncing' : 'offline'}`}>
      {isOnline ? (
        <>
          <span className="sync-icon"></span>
          <span>Syncing offline changes... Last sync: {formatLastSync(lastSyncTime)}</span>
        </>
      ) : (
        <>
          <span className="offline-icon"></span>
          <span>You're offline. Changes will sync when you reconnect.</span>
        </>
      )}
    </div>
  );
};

export default OfflineIndicator;
```

## Phase 4: Integration and Testing

# Detailed Plan: Implementing PWA Features & Testing Offline Functionality

## Phase 4: PWA Core Setup

### 4.1 Service Worker Configuration

Update the service worker registration to ensure proper offline functionality:

```typescript
// Enable service worker in production
const isLocalhost = Boolean(
  window.location.hostname === 'localhost' ||
    window.location.hostname === '[::1]' ||
    window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)
);

export function register(config?: any) {
  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {
    // The URL constructor is available in all browsers that support SW
    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);
    if (publicUrl.origin !== window.location.origin) {
      return;
    }

    window.addEventListener('load', () => {
      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;

      if (isLocalhost) {
        // This is running on localhost. Let's check if a service worker still exists or not.
        checkValidServiceWorker(swUrl, config);
      } else {
        // Is not localhost. Just register service worker
        registerValidSW(swUrl, config);
      }
    });
  }
}

function registerValidSW(swUrl: string, config?: any) {
  navigator.serviceWorker
    .register(swUrl)
    .then((registration) => {
      // Add update found handling for better UX
      registration.onupdatefound = () => {
        const installingWorker = registration.installing;
        if (installingWorker == null) {
          return;
        }
        installingWorker.onstatechange = () => {
          if (installingWorker.state === 'installed') {
            if (navigator.serviceWorker.controller) {
              // New content is available; notify user
              console.log('New content is available and will be used when all tabs for this page are closed.');
              if (config && config.onUpdate) {
                config.onUpdate(registration);
              }
            } else {
              // Content is cached for offline use
              console.log('Content is cached for offline use.');
              if (config && config.onSuccess) {
                config.onSuccess(registration);
              }
            }
          }
        };
      };
    })
    .catch((error) => {
      console.error('Error during service worker registration:', error);
    });
}

// Rest of the code remains unchanged
```

### 4.2 Advanced Service Worker with Workbox

Install Workbox for enhanced service worker capabilities:

```bash
npm install workbox-webpack-plugin workbox-core workbox-routing workbox-strategies workbox-precaching workbox-expiration --save-dev
```

Create a custom service worker:

```javascript
/// <reference lib="webworker" />

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;

clientsClaim();

// Precache all of the assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST);

// Cache the Google Fonts stylesheets with a stale-while-revalidate strategy
registerRoute(
  ({url}) => url.origin === 'https://fonts.googleapis.com',
  new StaleWhileRevalidate({
    cacheName: 'google-fonts-stylesheets',
  })
);

// Cache the underlying font files with a cache-first strategy
registerRoute(
  ({url}) => url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
);

// Cache JavaScript and CSS files with StaleWhileRevalidate
registerRoute(
  ({request}) => request.destination === 'script' || request.destination === 'style',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
  })
);

// Cache images with a cache-first strategy
registerRoute(
  ({request}) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// Cache API calls with NetworkFirst strategy
registerRoute(
  ({url}) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-responses',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 24 * 60 * 60, // 1 day
      }),
    ],
  })
);

// Handle navigation requests with NetworkFirst strategy
registerRoute(
  ({request}) => request.mode === 'navigate',
  new NetworkFirst({
    cacheName: 'navigations',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
      }),
    ],
  })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});
```

### 4.3 Web App Manifest Optimization

Update the manifest.json file to make the PWA installable and provide a proper app experience:

```json
{
  "short_name": "Excel Workout",
  "name": "Excel Workout Tracker",
  "description": "Track and manage your workout programs from Excel files",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192",
      "purpose": "any maskable"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512",
      "purpose": "any maskable"
    }
  ],
  "start_url": "/",
  "scope": "/",
  "display": "standalone",
  "theme_color": "#121212",
  "background_color": "#121212",
  "orientation": "portrait-primary",
  "categories": ["fitness", "health", "productivity"],
  "screenshots": [
    {
      "src": "screenshot1.png",
      "type": "image/png",
      "sizes": "1280x720"
    },
    {
      "src": "screenshot2.png",
      "type": "image/png",
      "sizes": "1280x720"
    }
  ],
  "shortcuts": [
    {
      "name": "Upload Workout",
      "short_name": "Upload",
      "description": "Upload a new workout file",
      "url": "/upload",
      "icons": [{ "src": "upload-icon.png", "sizes": "192x192" }]
    },
    {
      "name": "My Programs",
      "short_name": "Programs",
      "description": "View my workout programs",
      "url": "/programs",
      "icons": [{ "src": "programs-icon.png", "sizes": "192x192" }]
    }
  ]
}
```

### 4.4 Enable PWA Features in index.html

Update the HTML to include necessary PWA meta tags:

```html
/public/index.html -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" />
    <meta name="theme-color" content="#121212" />
    <meta name="description" content="Excel Workout - Track and manage your workout programs from Excel files" />
    
    <!-- iOS specific PWA tags -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="Excel Workout" />
    
    <!-- App icons -->
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="%PUBLIC_URL%/logo152.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="%PUBLIC_URL%/logo180.png" />
    <link rel="apple-touch-icon" sizes="167x167" href="%PUBLIC_URL%/logo167.png" />
    
    <!-- Splash screens for iOS -->
    <link rel="apple-touch-startup-image" href="%PUBLIC_URL%/splash/apple-splash-2048-2732.png" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" />
    <link rel="apple-touch-startup-image" href="%PUBLIC_URL%/splash/apple-splash-1668-2388.png" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" />
    <link rel="apple-touch-startup-image" href="%PUBLIC_URL%/splash/apple-splash-1536-2048.png" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" />
    <link rel="apple-touch-startup-image" href="%PUBLIC_URL%/splash/apple-splash-1125-2436.png" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)" />
    <link rel="apple-touch-startup-image" href="%PUBLIC_URL%/splash/apple-splash-750-1334.png" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" />
    
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>Excel Workout</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>
```

## Phase 5: Offline Detection & Handling

### 5.1 Create Offline Context Provider

```typescript
import React, { createContext, useState, useEffect, useContext, ReactNode } from 'react';

interface OfflineContextType {
  isOffline: boolean;
  lastOnlineAt: Date | null;
  isAppInstalled: boolean;
  deferredPrompt: any;
  showInstallPrompt: () => Promise<boolean>;
}

const OfflineContext = createContext<OfflineContextType>({
  isOffline: false,
  lastOnlineAt: null,
  isAppInstalled: false,
  deferredPrompt: null,
  showInstallPrompt: async () => false,
});

export const OfflineProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [isOffline, setIsOffline] = useState(!navigator.onLine);
  const [lastOnlineAt, setLastOnlineAt] = useState<Date | null>(navigator.onLine ? new Date() : null);
  const [deferredPrompt, setDeferredPrompt] = useState<any>(null);
  const [isAppInstalled, setIsAppInstalled] = useState(false);

  // Handle online/offline events
  useEffect(() => {
    const handleOnline = () => {
      setIsOffline(false);
      setLastOnlineAt(new Date());
    };

    const handleOffline = () => {
      setIsOffline(true);
    };

    // Check if app is installed
    const checkInstalled = () => {
      setIsAppInstalled(
        window.matchMedia('(display-mode: standalone)').matches || 
        (window.navigator as any).standalone === true
      );
    };

    // Capture install prompt
    const handleBeforeInstallPrompt = (e: any) => {
      e.preventDefault();
      setDeferredPrompt(e);
    };

    // Handle app installed
    const handleAppInstalled = () => {
      setIsAppInstalled(true);
      setDeferredPrompt(null);
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
    window.addEventListener('appinstalled', handleAppInstalled);
    checkInstalled();

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
      window.removeEventListener('appinstalled', handleAppInstalled);
    };
  }, []);

  // Show installation prompt
  const showInstallPrompt = async (): Promise<boolean> => {
    if (!deferredPrompt) {
      return false;
    }

    // Show the install prompt
    deferredPrompt.prompt();

    // Wait for the user to respond to the prompt
    const choiceResult = await deferredPrompt.userChoice;
    setDeferredPrompt(null);

    return choiceResult.outcome === 'accepted';
  };

  return (
    <OfflineContext.Provider value={{ 
      isOffline, 
      lastOnlineAt, 
      isAppInstalled, 
      deferredPrompt, 
      showInstallPrompt 
    }}>
      {children}
    </OfflineContext.Provider>
  );
};

export const useOffline = () => useContext(OfflineContext);
```

### 5.2 Enhance the OnlineStatusIndicator Component

```typescript
import React from 'react';
import { useOffline } from '../../contexts/OfflineContext';
import styles from './online-status.module.css';

interface OnlineStatusIndicatorProps {
  showInstallButton?: boolean;
}

export const OnlineStatusIndicator: React.FC<OnlineStatusIndicatorProps> = ({ 
  showInstallButton = true 
}) => {
  const { 
    isOffline, 
    lastOnlineAt, 
    isAppInstalled,
    deferredPrompt,
    showInstallPrompt
  } = useOffline();

  const handleInstallClick = async () => {
    const installed = await showInstallPrompt();
    if (installed) {
      // Show success message or take other actions after installation
      console.log('App was installed successfully');
    }
  };

  return (
    <div className={styles.container}>
      <div className={`${styles.indicator} ${isOffline ? styles.offline : styles.online}`}>
        <span className={styles.dot}></span>
        <span className={styles.text}>
          {isOffline ? 'Offline' : 'Online'}
        </span>
        {isOffline && lastOnlineAt && (
          <span className={styles.lastSeen}>
            Last online: {lastOnlineAt.toLocaleTimeString()}
          </span>
        )}
      </div>
      
      {showInstallButton && deferredPrompt && !isAppInstalled && (
        <button 
          className={styles.installButton} 
          onClick={handleInstallClick}
          aria-label="Install application"
        >
          Install App
        </button>
      )}

      {isAppInstalled && (
        <div className={styles.installedBadge}>
          Installed
        </div>
      )}
    </div>
  );
};
```

### 5.3 Create Offline Banner Component

```typescript
import React from 'react';
import { useOffline } from '../../contexts/OfflineContext';
import styles from './offline-banner.module.css';

export const OfflineBanner: React.FC = () => {
  const { isOffline } = useOffline();

  if (!isOffline) {
    return null;
  }

  return (
    <div className={styles.banner} role="alert">
      <span className={styles.icon}>⚠️</span>
      <p className={styles.message}>
        You're currently offline. Some features may be limited.
      </p>
    </div>
  );
};
```

```css
.banner {
  display: flex;
  align-items: center;
  padding: 10px 15px;
  background-color: #fff3cd;
  color: #856404;
  border-radius: 4px;
  margin: 10px 0;
  font-size: 14px;
  animation: slideDown 0.3s ease-out forwards;
}

.icon {
  margin-right: 10px;
  font-size: 18px;
}

.message {
  margin: 0;
}

@keyframes slideDown {
  from {
    transform: translateY(-100%);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

@media (prefers-color-scheme: dark) {
  .banner {
    background-color: #2c2100;
    color: #ffe69c;
  }
}
```

## Phase 6: Update Service Layer for Offline Support

### 6.1 Enhance StorageService with Sync Queue

```typescript
// Add a sync queue for offline operations
export class SyncQueue {
  private queue: Array<{
    action: string;
    payload: any;
    timestamp: number;
    id: string;
  }> = [];
  private readonly storageKey = 'excel_workout_sync_queue';
  
  constructor() {
    this.loadQueue();
  }
  
  private loadQueue(): void {
    const savedQueue = localStorage.getItem(this.storageKey);
    if (savedQueue) {
      try {
        this.queue = JSON.parse(savedQueue);
      } catch (e) {
        console.error('Failed to parse sync queue', e);
        this.queue = [];
      }
    }
  }
  
  private saveQueue(): void {
    localStorage.setItem(this.storageKey, JSON.stringify(this.queue));
  }
  
  add(action: string, payload: any): void {
    this.queue.push({
      action,
      payload,
      timestamp: Date.now(),
      id: `${action}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
    });
    this.saveQueue();
  }
  
  getAll(): Array<any> {
    return [...this.queue];
  }
  
  remove(id: string): void {
    this.queue = this.queue.filter(item => item.id !== id);
    this.saveQueue();
  }
  
  clear(): void {
    this.queue = [];
    this.saveQueue();
  }
}

// Enhance the storage service
export class EnhancedStorageService implements StorageService {
  private readonly baseService: StorageService;
  private readonly syncQueue: SyncQueue;
  private isOnline: boolean;
  
  constructor(baseService: StorageService) {
    this.baseService = baseService;
    this.syncQueue = new SyncQueue();
    this.isOnline = navigator.onLine;
    
    // Listen for online/offline events
    window.addEventListener('online', this.handleOnline);
    window.addEventListener('offline', this.handleOffline);
  }
  
  private handleOnline = async (): Promise<void> => {
    this.isOnline = true;
    await this.processSyncQueue();
  };
  
  private handleOffline = (): void => {
    this.isOnline = false;
  };
  
  private async processSyncQueue(): Promise<void> {
    if (!this.isOnline) return;
    
    const items = this.syncQueue.getAll();
    for (const item of items) {
      try {
        switch (item.action) {
          case 'storeWorkoutProgram':
            await this.baseService.storeWorkoutProgram(item.payload);
            break;
          case 'deleteWorkoutProgram':
            await this.baseService.deleteWorkoutProgram(item.payload);
            break;
          case 'storeWorkoutSession':
            await this.baseService.storeWorkoutSession(item.payload);
            break;
          default:
            console.warn(`Unknown action in sync queue: ${item.action}`);
        }
        this.syncQueue.remove(item.id);
      } catch (error) {
        console.error(`Failed to process sync queue item ${item.id}`, error);
        // If it's been in the queue for more than 7 days, remove it
        if (Date.now() - item.timestamp > 7 * 24 * 60 * 60 * 1000) {
          this.syncQueue.remove(item.id);
        }
      }
    }
  }
  
  // Override methods to handle offline mode
  async storeWorkoutProgram(program: WorkoutProgram): Promise<WorkoutProgram> {
    if (this.isOnline) {
      return this.baseService.storeWorkoutProgram(program);
    } else {
      // Store locally and queue for sync
      this.syncQueue.add('storeWorkoutProgram', program);
      // Also use local storage for immediate access
      const programs = JSON.parse(localStorage.getItem('workout_programs') || '[]');
      const existingIndex = programs.findIndex((p: WorkoutProgram) => p.id === program.id);
      if (existingIndex >= 0) {
        programs[existingIndex] = program;
      } else {
        programs.push(program);
      }
      localStorage.setItem('workout_programs', JSON.stringify(programs));
      return program;
    }
  }
  
  // Implement similar patterns for other methods
  // ...
}

// Factory function to create the enhanced service
export function createOfflineEnabledStorageService(): StorageService {
  const baseService = serviceFactory.getStorageService();
  return new EnhancedStorageService(baseService);
}
```

## Phase 7: Service Worker Update Notification

### 7.1 Create Update Notification Component

```typescript
import React, { useState, useEffect } from 'react';
import { register } from '../../serviceWorkerRegistration';
import styles from './update-notification.module.css';

export const UpdateNotification: React.FC = () => {
  const [showReload, setShowReload] = useState(false);
  const [waitingWorker, setWaitingWorker] = useState<ServiceWorker | null>(null);

  useEffect(() => {
    // Register the service worker with custom callbacks
    register({
      onUpdate: (registration: ServiceWorkerRegistration) => {
        setShowReload(true);
        setWaitingWorker(registration.waiting);
      },
    });
  }, []);

  const handleReload = () => {
    waitingWorker?.postMessage({ type: 'SKIP_WAITING' });
    setShowReload(false);
    window.location.reload();
  };

  if (!showReload) {
    return null;
  }

  return (
    <div className={styles.updateNotification}>
      <div className={styles.message}>
        A new version of the app is available!
      </div>
      <button onClick={handleReload} className={styles.reloadButton}>
        Update & Reload
      </button>
    </div>
  );
};
```

```css
.updateNotification {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  background-color: #323232;
  color: white;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 24px;
  border-radius: 4px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
  z-index: 9999;
  animation: slideUp 0.3s ease-out;
  max-width: 90%;
  width: 400px;
}

.message {
  margin-right: 16px;
  font-size: 14px;
}

.reloadButton {
  background-color: #4caf50;
  color: white;
  border: none;
  border-radius: 4px;
  padding: 8px 16px;
  cursor: pointer;
  font-weight: 600;
  transition: background-color 0.2s;
}

.reloadButton:hover {
  background-color: #43a047;
}

@keyframes slideUp {
  from {
    transform: translate(-50%, 100px);
    opacity: 0;
  }
  to {
    transform: translate(-50%, 0);
    opacity: 1;
  }
}
```

### 7.2 Update App.tsx to Include New Components

```tsx
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { AppContent } from './App';
import { OfflineProvider } from './contexts/OfflineContext';
import { OfflineBanner } from './components/OfflineBanner/OfflineBanner';
import { UpdateNotification } from './components/UpdateNotification/UpdateNotification';
import './App.css';

function App() {
  return (
    <OfflineProvider>
      <Router>
        <div className="app-container">
          <OfflineBanner />
          <Routes>
            <Route path="/" element={<AppContent />} />
            {/* Additional routes */}
          </Routes>
          <UpdateNotification />
        </div>
      </Router>
    </OfflineProvider>
  );
}

// Rest of the file remains the same
```

## Phase 8: Testing Offline Functionality

### 8.1 Manual Testing Checklist

Create a comprehensive testing plan for offline functionality:

```markdown
# PWA Offline Testing Checklist

## Initial Setup
- [ ] Install application to home screen
- [ ] Verify app launches correctly from home screen icon
- [ ] Verify splash screen appears (iOS)

## Basic Offline Functionality
- [ ] Turn off network (airplane mode)
- [ ] Refresh application
- [ ] Verify app loads without network
- [ ] Verify offline banner appears
- [ ] Verify basic navigation works

## Data Persistence
- [ ] Upload program while online
- [ ] Turn off network
- [ ]

Similar code found with 4 license types

# Analysis and Enhancement of PWA Implementation Plan

Your implementation plan for PWA features and offline functionality is already quite comprehensive. Here are some additional elements and steps to ensure a complete PWA implementation:

## Additional Core Elements to Consider

### 1. Complete Testing Strategy (Phase 8)
Your testing checklist is incomplete. Here's a more comprehensive testing approach:

```markdown
## Data Persistence Testing
- [ ] Upload program while online
- [ ] Turn off network
- [ ] Attempt to view uploaded program (should work offline)
- [ ] Make changes to program while offline
- [ ] Turn network back on
- [ ] Verify changes synced correctly

## Background Sync Testing
- [ ] Turn off network
- [ ] Create new workout sessions
- [ ] Turn network back on
- [ ] Verify data syncs automatically without user action
- [ ] Check sync success notifications

## Multi-device Testing
- [ ] Test on iOS Safari
- [ ] Test on Android Chrome
- [ ] Test on desktop browsers (Chrome, Firefox, Edge)
- [ ] Test on tablet devices

## Network Resilience Testing
- [ ] Test with slow connections (throttling in DevTools)
- [ ] Test transitioning between online/offline repeatedly
- [ ] Test behavior when server returns errors
```

### 2. Improved Error Handling and Recovery

```typescript
// Add robust error handling to sync process
async function syncWorkoutData() {
  const MAX_RETRIES = 3;
  
  const dbPromise = indexedDB.open('workout-sync-store', 1);
  // ... existing code ...
  
  // Process each item in the queue with retry logic
  for (const item of items) {
    let retries = 0;
    let success = false;
    
    while (retries < MAX_RETRIES && !success) {
      try {
        await fetch(item.url, {
          method: item.method,
          headers: item.headers,
          body: item.body,
          // Set timeout to avoid long-hanging requests
          signal: AbortSignal.timeout(10000)
        });
        
        success = true;
        store.delete(item.id);
        
        // Notify the user that sync was successful
        self.registration.showNotification('Sync Complete', {
          body: 'Your offline changes have been saved.',
          icon: '/logo192.png'
        });
      } catch (error) {
        retries++;
        console.error(`Error syncing data (attempt ${retries}/${MAX_RETRIES}):`, error);
        
        // Wait before retrying (exponential backoff)
        if (retries < MAX_RETRIES) {
          await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, retries)));
        } else {
          // Notify the user after all retries failed
          self.registration.showNotification('Sync Failed', {
            body: 'Some changes couldn\'t be saved. Please try again later.',
            icon: '/logo192.png'
          });
        }
      }
    }
  }
}
```

### 3. Accessibility Enhancements

```tsx
// Enhance OfflineIndicator with better accessibility
export const OfflineIndicator: React.FC = () => {
  const { isOnline, hasOfflineData } = useOffline();
  
  return (
    <div 
      className={`offline-indicator ${isOnline ? 'online' : 'offline'}`}
      role="status"
      aria-live="polite"
      aria-atomic="true"
    >
      {isOnline ? (
        <span aria-label="Online status">
          <span className="visually-hidden">You are online.</span>
          <span className="online-icon" aria-hidden="true"></span>
          {hasOfflineData && <span>Syncing changes...</span>}
        </span>
      ) : (
        <span aria-label="Offline status">
          <span className="visually-hidden">You are offline. Changes will be saved when you reconnect.</span>
          <span className="offline-icon" aria-hidden="true"></span>
          <span>You're offline</span>
        </span>
      )}
    </div>
  );
};

// Add these styles
.visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}
```

### 4. Analytics for Offline Usage

```typescript
// In your offline context provider
export const OfflineProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  // ... existing code ...
  
  // Track offline usage with metrics
  useEffect(() => {
    // Count offline sessions
    let offlineSessionStart: number | null = null;
    
    const trackOfflineSession = () => {
      if (!isOffline) {
        if (offlineSessionStart) {
          const duration = Date.now() - offlineSessionStart;
          // Log offline session duration
          console.log(`Offline session duration: ${duration}ms`);
          
          // Send to analytics when back online
          if (navigator.onLine) {
            try {
              // Example analytics call
              navigator.sendBeacon('/api/analytics/offline-usage', JSON.stringify({
                duration,
                timestamp: new Date().toISOString(),
                syncedData: hasOfflineData
              }));
            } catch (e) {
              console.error('Failed to send offline analytics', e);
            }
          }
          offlineSessionStart = null;
        }
      } else if (!offlineSessionStart) {
        offlineSessionStart = Date.now();
      }
    };
    
    // Run tracking when offline status changes
    trackOfflineSession();
    
    return () => {
      // Cleanup tracking when unmounting
      if (offlineSessionStart) {
        const duration = Date.now() - offlineSessionStart;
        console.log(`Final offline session duration: ${duration}ms`);
      }
    };
  }, [isOffline, hasOfflineData]);
  
  // ... rest of the provider
};
```

### 5. Security Enhancements for Offline Data

```typescript
// In your IndexedDB service
async initDB(): Promise<IDBDatabase> {
  if (this.db) return this.db;

  return new Promise((resolve, reject) => {
    const request = indexedDB.open(this.dbName, this.dbVersion);

    request.onupgradeneeded = (event) => {
      const db = (event.target as IDBOpenDBRequest).result;
      
      // Create object stores with encryption capability
      if (!db.objectStoreNames.contains('programs')) {
        const programsStore = db.createObjectStore('programs', { keyPath: 'id' });
        // Add indexes for better performance
        programsStore.createIndex('name', 'name', { unique: false });
        programsStore.createIndex('lastModified', 'lastModified', { unique: false });
      }
      
      // ... other stores
    };
    
    // ... rest of the initialization
  });
}

// Add data encryption helper (simplified example)
private async encryptData(data: any): Promise<string> {
  // Use the Web Crypto API for real encryption
  const encoder = new TextEncoder();
  const dataBuffer = encoder.encode(JSON.stringify(data));
  
  // This is a simplified example - in production use proper encryption
  return btoa(String.fromCharCode(...new Uint8Array(dataBuffer)));
}

private async decryptData(encryptedData: string): Promise<any> {
  // Corresponding decryption function
  const binaryString = atob(encryptedData);
  const bytes = new Uint8Array(binaryString.length);
  
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  
  const decoder = new TextDecoder();
  const decodedData = decoder.decode(bytes);
  
  return JSON.parse(decodedData);
}
```

### 6. Advanced PWA Features: Push Notifications

```typescript
// Request notification permissions
export function requestNotificationPermission(): Promise<NotificationPermission> {
  if (!('Notification' in window)) {
    console.log('This browser does not support notifications');
    return Promise.resolve('denied');
  }
  
  if (Notification.permission === 'granted') {
    return Promise.resolve('granted');
  }
  
  if (Notification.permission !== 'denied') {
    return Notification.requestPermission();
  }
  
  return Promise.resolve(Notification.permission);
}

// In your App component or offline provider
useEffect(() => {
  const setupPushNotifications = async () => {
    const permission = await requestNotificationPermission();
    
    if (permission === 'granted' && 'serviceWorker' in navigator) {
      const registration = await navigator.serviceWorker.ready;
      
      try {
        // Get push subscription
        let subscription = await registration.pushManager.getSubscription();
        
        if (!subscription) {
          // Create new subscription
          const vapidPublicKey = 'YOUR_PUBLIC_VAPID_KEY';
          const convertedKey = urlBase64ToUint8Array(vapidPublicKey);
          
          subscription = await registration.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: convertedKey
          });
          
          // Send subscription to server
          await fetch('/api/push/register', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(subscription)
          });
        }
      } catch (error) {
        console.error('Error setting up push notifications:', error);
      }
    }
  };
  
  setupPushNotifications();
}, []);

// Helper function for VAPID key conversion
function urlBase64ToUint8Array(base64String: string): Uint8Array {
  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding)
    .replace(/-/g, '+')
    .replace(/_/g, '/');
  
  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);
  
  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  
  return outputArray;
}
```

### 7. PWA Audit Process

Add a Lighthouse audit automation script:

```javascript
// lighthouse-audit.js
const lighthouse = require('lighthouse');
const chromeLauncher = require('chrome-launcher');
const { writeFileSync } = require('fs');
const { join } = require('path');

async function runLighthouseAudit() {
  const chrome = await chromeLauncher.launch({chromeFlags: ['--headless']});
  const options = {
    logLevel: 'info',
    output: 'html',
    onlyCategories: ['performance', 'accessibility', 'best-practices', 'seo', 'pwa'],
    port: chrome.port
  };
  
  const runnerResult = await lighthouse('https://your-pwa-url.com', options);
  
  // Write report to file
  const reportHtml = runnerResult.report;
  writeFileSync(join(__dirname, 'lighthouse-report.html'), reportHtml);
  
  await chrome.kill();
  
  // Log PWA score
  const pwaScore = runnerResult.lhr.categories.pwa.score * 100;
  console.log(`PWA Score: ${pwaScore}/100`);
  
  // Check PWA audit items
  const pwaAudits = runnerResult.lhr.categories.pwa.auditRefs.map(ref => {
    const audit = runnerResult.lhr.audits[ref.id];
    return {
      id: ref.id,
      title: audit.title,
      score: audit.score,
      passed: audit.score === 1
    };
  });
  
  console.log('PWA Audit Results:');
  pwaAudits.forEach(audit => {
    console.log(`${audit.passed ? '✅' : '❌'} ${audit.title}`);
  });
}

runLighthouseAudit();
```

Add to package.json:
```json
"scripts": {
  "audit-pwa": "node lighthouse-audit.js"
}
```
